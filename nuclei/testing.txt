
------------------------------- TESTING STRATEGY -------------------------------

  Standard error messages are turned off during testing and turned on for file
  reading. This means assertions are always active during development, and fail
  conditions can be tested without triggering standard errors.

  When testing the parser and interpreter a test.txt file is created and filed
  with the code to be tested. For each new test the file is re-written to. The
  functions are tested with the contents of this file. The file is deleted after
  testing.

  santitiser flags and valgrind have been used during testing to detect
  segfaults and memory leaks.

  WHITE BOX TESTING -- Bottom Up Approach
  While testing the NUCLEI program it is important to understand which functions
  should return a "false" boolean (e.g. when testing the parser functions) and
  why. Hence the tester needs to see the code (white box).

  For example, the program in quotes: "((SET A ))"
  The highest level function PROG returns "true", suggesting the code was parsed
  correctly. This is because the grammar definition of INSTRUCTS has been
  satisfied.

  Instead, the tester should know that the FUNC function returns false when
  passed the string "SET A ". Hence, the program does not successfully parse
  because a standard error is generated within FUNC. In this example the tester
  should assert that FUNC returns fail as opposed to testing if PROG returns
  fail. Hence the testing strategy is the white box method.

  A bottom up strategy has been used during the testing. Testing smaller
  functions thoroughly before testing higher up functions which rely upon the
  smaller ones.


- LEXICON ANALYSER TESTING
  The lexicon analyser returns tokens corresponding to the grammar, all tokens are
  defined in an enum.
  - Tested that lexicon analyser returns the correct tokens, otherwise returns the
    ERROR token.
  - Tested comments are ignored (any line which first character is '#')
  - Tested white space is ignored
  - Tested that the analyser stops when at the end of the inputted code.


- PARSER TESTING
  - Tested empty space is ignored in before, within and after functions with
    various combinations of white space (spaces, tabs and enters)
  - Asserted that all types of list functions are parsed correctly with the SET
    function (testing inputs to accept and testing inputs to reject)
  - Tested every function individually using different types of LISTS (VAR, NIL,
    LITERAL and RETFUNC)
  - Tested that relevant functions fail if passed other things than LISTS, e.g.
    FUNCTIONS or STRING or NULL
  - Tested missing a quote for a literal or a string returns a parser fail.
  - Tested the parser return the expected result for all of the example codes
    given on blackboard


- INTERP TESTING
  - Tested that variables A-Z are set to any kind of LIST value when in the SET
    function
  - Tested that function results are stored in the temporary result string.
  - Tested print deals with all types of LIST or STRING correctly
  - Tested  INTFUNCS, RETFUNCs, LISTFUNCs and BOOLFUNCs behave correctly for all
    types of LISTs
  - Tested IF skips the interpretation and parsing of the unrequired
    instructions
  - Tested WHILE repeats the instructions when the boolean is satisfied, and
    when the boolean is not satisfied the interpreter and parser skip the
    instructions.



  #ifdef DEBUG is included in the grammar functions. If #define DEBUG is present
  in the nuclei.h file the phrase:

  in *function name* token=*current token type*

  is printed in the terminal when in that function. This was a useful tool for
  debugging.
-
